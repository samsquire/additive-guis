<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>additive-guis live</title>
  <meta name="description" content="">
  <meta name="author" content="">

 <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/react/16.10.2/umd/react.development.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.10.2/umd/react-dom.development.js" type="text/javascript"></script>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

	<link href="https://getbootstrap.com/docs/4.0/examples/blog/blog.css" rel="stylesheet">
	
	<style>
	#input {
		float: left;
		top: 0px;
		width: 30vw;
		height: 100vh;
		position: sticky;
	}
	#output {
		width: 100%;
		margin-top: 0;
		margin-left: 30vw;
		overflow: scroll;
		position: absolute;
		top: 0px;
	}
	.folder-list {
		border: 3px inset;
	}
	.email-list {
		border: 3px inset;
	}
	.mail-preview {
		border: 3px inset;
	}

	</style>

</head>

<body>
<textarea id="input"></textarea>
<div id="output"></div>
<script type="text/javascript">
var groupBy = function(xs, key) {
  return xs.reduce(function(rv, x) {
    (rv[x[key]] = rv[x[key]] || []).push(x);
    return rv;
  }, {});
};
function shuffle(a) {
    var j, x, i;
    for (i = a.length - 1; i > 0; i--) {
        j = Math.floor(Math.random() * (i + 1));
        x = a[i];
        a[i] = a[j];
        a[j] = x;
    }
    return a;
}
// Sam Squire
var template = {
	"data": {
		"files": [
			{
				"name": "folder1",
				"children": [
					{
						"name": "folder2",
						"children": [
							{
								"name": "file1",
								"children": []
							}
						]
					}
				]
			}
		]
	},
	"predicates": [
		"filesView backedBy .files",
		"filesView mappedTo fileItems",
		"filesView key .name"
	],
	"widgets": {
		"fileItems": {
			"predicates": [
				"label hasContent .name",
				"moreItems backedBy .children",
				"moreItems mappedTo fileItems",
				"label above moreItems",
				"moreItems key .name"
			]
		}
	}
}

function Environment() {
	this.data = {};
	this.properties = {};
}

Environment.prototype.registerData = function (widget, data) {
		this.data[widget] = data;
		console.log("Registering data for ", widget);
}

Environment.prototype.hasProperty = function (widget) {
	return this.properties.hasOwnProperty(widget);
}
	
Environment.prototype.addProperty = function (property, widget, fn) {
	var properties;
	if (this.properties.hasOwnProperty(widget)) {
		properties = this.properties[widget];
	} else {
		this.properties[widget] = {};
		properties = this.properties[widget];
	}
	properties[property] = fn;
	
}


function layout_page(environment, values, template, data, classes, keyPostfix) {
	data = shuffle(data);
	console.log("data", JSON.stringify(data));
	var Problem = function() {
		this.variables = [];
		this.lookup = {};
		this.rules = [];
		this.ordering = {
			"x": [],
			"y": []
		}
		this.data = [];
		this.ruleIndex = {};
		this.properties = {};
	}

	var Declaration = function (name) {
		this.name = name;
		this.x = 0;
		this.y = 0;
		this.size = "";
	}

	Problem.prototype.addDeclaration = function (name) {
		if (name == undefined) { debugger ; }
		var createdDeclaration = new Declaration(name)
		this.variables.push(createdDeclaration);
		this.lookup[name] = createdDeclaration;


	};

	var problem = new Problem();


	for (var i = 0 ; i < data.length; i++) {
		var item = data[i];
		
		var components = item.split(" ");
			
		if (components.length == 1) {
			// declaration
			if (!problem.lookup.hasOwnProperty(components[0])) {
				problem.addDeclaration(components[0]);
			}
			
		} else {
			if (components[0] == "siblings") { continue }
			
			if (!problem.lookup.hasOwnProperty(components[0])) { problem.addDeclaration(components[0]); }
			if (components[1] == "hasSize") { continue }
			if (components[1] == "is") { continue }
			if (components[1] == "key") { continue }
			if (components[1] == "mappedTo") { continue }
			if (components[1] == "backedBy") { continue }
			if (components[1] == "hasClass") { continue }
			if (components[1] == "selects") { continue }
			if (components[1] == "emits") { continue }
			if (components[1] == "hasContent") { continue }
			if (!problem.lookup.hasOwnProperty(components[2])) { problem.addDeclaration(components[2]); }
			
		}
	}

	for (var i = 0 ; i < data.length; i++) {
		var item = data[i];
		
		var components = item.split(" ");
		
		if (components[1] == "hasSize") {
			problem.lookup[components[0]].size = components[2];
				
		}
	}
	
	Problem.prototype.hasProperty = function (widget) {
		return this.properties.hasOwnProperty(widget);

	}
	
	Problem.prototype.addProperty = function (property, widget, fn) {
		var properties;
		if (this.properties.hasOwnProperty(widget)) {
			properties = this.properties[widget];
		} else {
			this.properties[widget] = {};
			properties = this.properties[widget];
		}
		properties[property] = fn;
		
	}

	Problem.prototype.addRule = function (coordinate, rule, left, right) {
		var needInsertLeft = false;
		if (this.ordering[coordinate].indexOf(left) == -1) {
			needInsertLeft = true;
			for (var i = 0; i < this.ordering[coordinate].length; i++) {
				if (Array.isArray(this.ordering[coordinate][i])) {
					if (this.ordering[coordinate][i].indexOf(left) != -1) {
						needInsertLeft = false;
					}
				}	
			}
		}
		var needInsertRight = false;
		if (this.ordering[coordinate].indexOf(right) == -1) {
			needInsertRight = true;
			for (var i = 0; i < this.ordering[coordinate].length; i++) {
				if (Array.isArray(this.ordering[coordinate][i])) {
					if (this.ordering[coordinate][i].indexOf(right) != -1) {
						needInsertRight = false;
					}
				}	
			}
		}
		if (needInsertLeft == true && needInsertRight == false) {
			for (var i = 0 ; i < this.ordering[coordinate].length ; i++) {
				var current = this.ordering[coordinate][i];
				if (current === right) {
					// we need to insert left before right
					this.ordering[coordinate].splice(i, 0, left);
					break;
				}
			}
		}
		else if (needInsertLeft == false && needInsertRight == true) {
			for (var i = 0 ; i < this.ordering[coordinate].length ; i++) {
				var current = this.ordering[coordinate][i];
				if (current == left) {
					// we need to insert left before right
					this.ordering[coordinate].splice(i + 1, 0, right);
					break;
				}
			}
		} else if (needInsertLeft == true && needInsertRight == true) {
			this.ordering[coordinate].push(left);
			this.ordering[coordinate].push(right);
		} else if (needInsertLeft == false && needInsertRight == false) {
			// is left before right
			var rightPos = this.ordering[coordinate].indexOf(right);
			var foundRight = false;
			var isCollection = false;
			for (var i = 0; i < this.ordering[coordinate].length; i++) {
				if (Array.isArray(this.ordering[coordinate][i])) {
					if (this.ordering[coordinate][i].indexOf(right) != -1) {
						foundRight = true;
						rightPos = i;
						isCollection = true;
						break;
					}
				}
			}
			var leftPos = this.ordering[coordinate].indexOf(left);
			for (var i = 0; i < this.ordering[coordinate].length; i++) {
				if (Array.isArray(this.ordering[coordinate][i])) {
					if (this.ordering[coordinate][i].indexOf(left) != -1) {
						foundLeft = true;
						leftPos = i;
						isCollection = true;
						break;
					}
				}
			}
			console.log("rightPos", rightPos);
			
			if (! (leftPos < rightPos)) {
				var backup;
				console.log("Swap needed", left, right);
				console.log("swap", rightPos);
				
				if (isCollection) {
					backup = this.ordering[coordinate][leftPos];
					console.log("backup", backup);
				}
				// delete left
				this.ordering[coordinate].splice(leftPos, 1);
				var rightBackup;	
				if (isCollection) {
					rightBackup = this.ordering[coordinate][rightPos];
					this.ordering[coordinate][rightPos] = backup;
					
				} else {
					rightBackup = this.ordering[coordinate][rightPos];
					this.ordering[coordinate][rightPos] = left;
					
				}
				console.log("rightbackup", rightBackup);
				console.log("insert", right);
				this.ordering[coordinate].splice(rightPos + 1, 0, rightBackup);
				
				
				console.log("swap", this.ordering[coordinate]);
				
			}
		}
		if (coordinate === "x") {
			if (rule === "leftOf" || rule === "rightOf") {
				console.log("Left", left, "and right", right, "have the same y");
				var found = false;
				for (var i = 0 ; i < this.ordering["y"].length ; i++) {
					var ordering = this.ordering["y"][i];
					var innerMove = false;
					if (ordering == left) {
						console.log("Found on the left");
						this.ordering["y"][i] = [left];
						// look for right in list
						for (var k = 0 ; k < this.ordering["y"].length; k++) {
							var inner = this.ordering["y"][k];
							if (Array.isArray(this.ordering["y"][i]) && Array.isArray(inner)) {
								console.log("Inner is a list");
								console.log("inner", inner);
								for (var m = 0; m < inner.length ; m++) {
									if (inner[m] === right) {
										console.log("We have to move what's here");
										innerMove = true;
										for (var thing of inner) {
											console.log("Moving", this.ordering["y"][i]);
											this.ordering["y"][i].push(thing);
										}
										this.ordering["y"].splice(k, 1);
									}
								}
								
							}
							
						}
						if (!innerMove) {
							this.ordering["y"][i].push(right);
						}
						if (this.ordering["y"].indexOf(right) != -1) {
							this.ordering["y"].splice(this.ordering["y"].indexOf(right), 1);
						}
						
						
						found = true;
						break;
					} else if (ordering == right) {
						console.log("Found on the right");
						this.ordering["y"][i] = [right];
						// look for right in list
						for (var k = 0 ; k < this.ordering["y"].length; k++) {
							var inner = this.ordering["y"][k];
							if (Array.isArray(this.ordering["y"][i]) && Array.isArray(inner)) {
								console.log("Inner is a list");
								console.log("inner", inner);
								for (var m = 0; m < inner.length ; m++) {
									if (inner[m] === left) {
										console.log("We have to move what's here");
										innerMove = true;
										for (var thing of inner) {
											console.log("Moving", this.ordering["y"][i]);
											this.ordering["y"][i].push(thing);
										}
										this.ordering["y"].splice(k, 1);
									}
								}
								
							}
							
						}
						if (!innerMove) {
							this.ordering["y"][i].push(left);
						}
						if (this.ordering["y"].indexOf(left) != -1) {
							this.ordering["y"].splice(this.ordering["y"].indexOf(left), 1);
						}
						
						found = true;
						break;
					}
					
					if (Array.isArray(ordering)) {
						console.log("Multiple things in the same Y");
						var size = ordering.length;
					
						for (var j = 0 ; j < size ; j++) {
							var item = ordering[j];
							if (item == left && ordering.indexOf(right) == -1) { found = true; ordering.push(right); break; }
							if (item == right && ordering.indexOf(left) == -1) { found = true; ordering.push(left); break; }
						}
						if (!found) {  }
					}
					
				}
				
				for (var i = 0 ; i < this.ordering["y"].length ; i++) {
					var current = this.ordering["y"][i];
					if (Array.isArray(current)) {
						for (var item of current) {
							this.lookup[item]["y"] = i + 1;
						}
					} else {
						this.lookup[current]["y"] = i + 1;
					}
					
				}
				
				if (!found) {
					// this.ordering["y"].push([left, right]);
					console.log(JSON.stringify(this.ordering["y"]));
					console.log("We need to introduce into Y");
					
				}
								
			}
		}
		for (var i = 0 ; i < this.ordering[coordinate].length ; i++) {
			var current = this.ordering[coordinate][i];
			
			if (Array.isArray(current)) {
			    
				for (var item of current) {
					this.lookup[item][coordinate] = i + 1;
				}
			} else {
				
				this.lookup[current][coordinate] = i + 1;
			}
			
		}
		
		console.log("y", JSON.stringify(this.ordering["y"]));
		// console.log("x", this.ordering["x"]);
		var ruleKey = coordinate + rule + left + right;
		if (!this.ruleIndex.hasOwnProperty(ruleKey)) {
			this.rules.push([coordinate, rule, left, right]);
			this.ruleIndex[ruleKey] = true;
		}
		
	}

	Problem.prototype.solve = function () {
		/* Re-apply rules to catch errors */
		for (var i = 0 ; i < this.rules.length; i++) {
			this.addRule.apply(this, this.rules[i]);
		}
		return this.variables;
	}


	

	for (var i = 0 ; i < data.length; i++) {
		var item = data[i];
		console.log(item);
		var components = item.split(" ");
		if (components.length == 3) {
			// rule
			if (components[1] === "above") {
			
				problem.addRule("y", components[1], components[0], components[2]);
			}
			if (components[1] === "leftOf") {
				
				problem.addRule("x", components[1], components[0], components[2]);
			}
			if (components[1] === "rightOf") {
			
				problem.addRule("x", components[1], components[2], components[0]);
			}
			if (components[1] === "mappedTo") {
				problem.addProperty("mappedTo", components[0],
					
						template.widgets[components[2]]
					
				);
			}
			if (components[1] === "backedBy") {
				problem.addProperty("backedBy", components[0], 
					function (field) {
						return function (data) {
							if (field.length > 1) {
								
								return data[field.replace(".", "")];
							}
							return data;
					}
				}(components[2]));
			}
			if (components[1] === "hasContent") {
				problem.addProperty("hasContent", components[0], components[2]);
			}
			if (components[1] === "emits") {
				problem.addProperty("emits", components[0], components[2]);
			}
			if (components[1] === "key") {
				problem.addProperty("key", components[0], components[2]);
			}
			if (components[1] === "selects") {
				environment.addProperty("selects", components[0], components[2]);
				environment.addProperty("receives", components[2]);
			}
			if (components[1] === "hasClass") {
				problem.addProperty("hasClass", components[0], components[2]);
			}
			if (components[1] === "is") {
				problem.addProperty("is", components[0], components[2]);
			}
			
		}
	}
	var ordered = problem.solve();
	
	var grouped = groupBy(ordered, 'y');
	
	var rows = Object.keys(grouped).sort(function (a, b) { return Number(a) < Number(b) ? -1 : 1 }).map(function (item) {
		
		return {key: item, items: grouped[item]};
	}).map(function (item) {
		var colChildren = item.items.sort(function (a, b)  { return Number(a.x) < Number(b.x) ? -1 : 1 }).map(function (cell) {
			
			var contents = cell.name;
			
			var attr = {key: cell.name + keyPostfix, className: "col"}
			var size;
			
			size = cell.size;
			attr["className"] += " col-md-" + size;
			
			
			var renderData = {};
			if (template.widgets.hasOwnProperty(cell.name)) { 
				renderData = template.widgets[cell.name];
			}
			// dynamic rules
			// console.log(cell.name);
			console.log("cell name", cell.name);
			if (problem.hasProperty(cell.name)) {
				if (problem.properties[cell.name].hasOwnProperty("hasClass")) {
				
					attr["className"] += " " + problem.properties[cell.name].hasClass;
				}
				// console.log("Dynamic rule", cell.name, problem.properties[cell.name]);
				if (problem.properties[cell.name].hasOwnProperty("mappedTo") && (problem.properties[cell.name].hasOwnProperty("backedBy") ||  (environment.hasProperty(cell.name) && environment.properties[cell.name].hasOwnProperty("receives")))) {
					// console.log("Can map");
					var dataSource;
					if (environment.hasProperty(cell.name) && environment.properties[cell.name].hasOwnProperty("receives")) {
						// console.log("Mapping", cell.name, environment.data);
						// console.log(cell.name);
						dataSource = environment.data[cell.name] || [];
						// console.log(dataSource);
					} else {
						dataSource = problem.properties[cell.name].backedBy(values)
						// console.log(dataSource);
					}
					if (Array.isArray(dataSource)) {
						var screenItems = dataSource.map(function (dataItem) {
							var keyPostfix = dataItem[problem.properties[cell.name].key.replace(".", "")];
							var contents = layout_page(environment, dataItem, template, problem.properties[cell.name]["mappedTo"]["predicates"], classes, keyPostfix);
							return contents;
					});
					
					// console.log(screenItems);
					attr["key"] = cell.name;
					return React.createElement("div", attr, screenItems);

					} else {
						var dataItem = dataSource;
						var keyPostfix = dataItem[problem.properties[cell.name].key.replace(".", "")];
						
						var contents = layout_page(environment, dataItem, template, problem.properties[cell.name]["mappedTo"]["predicates"], classes, keyPostfix);
						return React.createElement("div", attr, contents);
					}
				
				}
				if (problem.properties[cell.name].hasOwnProperty("emits")) {
					// console.log("Creating event handler for", cell.name);
					attr["onClick"] = function (problem, environment, cell) {
						return function () {
							var emits = problem.properties[cell.name].emits;
							console.log("Need to re-render", environment.properties[cell.name].selects, "with", emits);
							if (emits === ".") {
								toRender = values;
							} else {
								toRender = values[emits.replace(".", "")];
							}
							// console.log("Mapping", toRender);
							// console.log("Register data", cell.name);
							environment.registerData(environment.properties[cell.name].selects, toRender);
							rerender();
						}
					}(problem, environment, cell);
				}
				if (problem.properties[cell.name].hasOwnProperty("hasContent")) {
					var contentSpecifier = problem.properties[cell.name]["hasContent"];
					var content;
					if (contentSpecifier.indexOf(".") != -1) {
						content = values[contentSpecifier.replace(".", "")];
					} else {
						content = contentSpecifier;
					}
					attr["key"] = content;
					/* attr["dangerouslySetInnerHTML"] = {
						"__html": 
					}*/
					return React.createElement("div", attr, content);
					
				}
				
			}
			
			if (renderData.hasOwnProperty("html")) {
				attr["dangerouslySetInnerHTML"] = {
					"__html": renderData["html"]
				}
				contents = null;
			}
			if (renderData.hasOwnProperty("predicates")) {
				var classes = "";
				if (renderData.hasOwnProperty("classes")) {
					classes = renderData["classes"];
					
				}
				contents = layout_page(environment, values, template, renderData["predicates"], classes, cell.name);
				
				return React.createElement("div", attr, contents);
				
			}
			
			return React.createElement("div", attr, contents);
		});
		
		var gridStyles = "";
		gridStyles = "row"
		
		
		return React.createElement("div", {key: item.key, className: gridStyles},colChildren);
	})
	
	var container = React.createElement('div', {key: keyPostfix, className: "container " + classes }, rows);
	return container;
}


var output = document.getElementById("output");

document.getElementById("input").value = JSON.stringify(template, null, 4);
var inputField = document.getElementById("input");
inputField.addEventListener('change', function () {
	
	template = JSON.parse(inputField.value);
	widgets = template["widgets"];
	all_predicates = template["predicates"];
	rerender();
});
var environment = new Environment();
function rerender() {
	
	ReactDOM.render(layout_page(environment, template.data, template, template.predicates, "", "root"), output);
}
rerender();
</script>




</body>
</html>

